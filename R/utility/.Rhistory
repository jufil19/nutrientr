cn_cleandata <- function(cn_api_output) {
df <- as.data.frame(do.call(rbind, cn_api_output$content))
# Check if the dataframe is empty
if (nrow(df) == 0) {
stop("The requested query has no result")
}
# Each column is a list, we thus need to unnest every column
# This way, R will be able to attribute the appropriate type to each column
df_unnest <- unnest(df, cols = all_of(colnames(df)))
# output the tibble
df_unnest
}
#' cn_api
#' Makes a query to the Canadian Nutrient Files API.
#'
#' @param path the path to the desired endpoint. (Should be one of food, nutrientamount
#' nutrientgroup, nutrientname, nutrientsource, refuseamount, servingsize, or yieldamount.)
#' @param userKey key to access the API. Can be retrieved from <https://hc-sc.api.canada.ca/en/detail?api=cnf#!/Nutrient/get_nutrientamount>.
#' If none is provided, @seealso [get_key()] will check the system environments for one.
#' @param id the id of what you're looking for. Meaning of the id changes depending on endpoint.
#' @param lang the language you are using and want results returned in.
#'
#' @return a structure with the parsed text response, the raw response, the endpoint path, and the id.
#'
#' @references Note that this function is based on, and repeats much of the code in
#' the R API package best practices,
#' available at <https://httr.r-lib.org/articles/api-packages.html#overall-design-1>.
#'
#' @examples
#' cn_api("food")
#' cn_api("food", id = 2314)
#'
#' @export
#'
cn_api <- function(path, apiKey = NULL, id = NULL, lang = "en") {
if (is.null(path)){
stop("You need to specify and endpoint.")
}
# Should no key be provided, check to see if one
# is saved as as a system variable.
if (is.null(apiKey)) {
apiKey <- get_key()
}
# Set a user agent.
ua <- user_agent('https://github.com/jufil19/nutrientr')
# Make sure all the necessary components are ready to make a query.
url <- modify_url("https://cnf-hc-sc-apicast-production.api.canada.ca", path = paste('v1/', path, sep = ''))
query <- list(lang = lang, id = id, type = 'json')
header <- add_headers("user-key" = apiKey)
resp <- GET(url, ua, header, query = query)
# Need to verify output was JSON as it should be.
if (http_type(resp) != "application/json") {
# Check status code since the API doesn't return json if there is an error.
if (status_code(resp) != 200) {
stop(
paste("Canadian Nutrient File API request failed:", status_code(resp), rawToChar(resp$content)),
call. = FALSE
)
}
# Otherwise the call was valid but response was not json.
stop("API did not return json", call. = FALSE)
}
# Now parse the text output from the response.
parsed <-  jsonlite::fromJSON(content(resp, "text"), simplifyVector = FALSE)
# Check status code to make sure query was successful and if not provide useful errors.
if (status_code(resp) != 200) {
stop(
paste("Canadian Nutrient File API request failed:", status_code(resp), parsed$Message, parsed$documentation_url),
call. = FALSE
)
}
# Return all of the relevant information in a structure for easy access.
structure(
list(
content = parsed,
path = path,
id = id,
response = resp
),
class = "cn_api"
)
}
usethis::use_test("query_api")
setwd("~/OneDrive - UBC/MDS/Block 4/534/nutrientr/R/utility")
usethis::use_test("query_api")
usethis::use_test("clean_data")
# Helper function that formats the output of the query_api function into a tibble with appropriate column types
# This function will not be visible by users
clean_data <- function(query_api_output) {
df <- as.data.frame(do.call(rbind, query_api_output$content))
# Check if the dataframe is empty
if (nrow(df) == 0) {
stop("The requested query has no result")
}
# Each column is a list, we thus need to unnest every column
# This way, R will be able to attribute the appropriate type to each column
df_unnest <- unnest(df, cols = all_of(colnames(df)))
# output the tibble
df_unnest
}
#' query_api
#' Makes a query to the Canadian Nutrient Files API.
#'
#' @param path the path to the desired endpoint. (Should be one of food, nutrientamount
#' nutrientgroup, nutrientname, nutrientsource, refuseamount, servingsize, or yieldamount.)
#' @param userKey key to access the API. Can be retrieved from <https://hc-sc.api.canada.ca/en/detail?api=cnf#!/Nutrient/get_nutrientamount>.
#' If none is provided, @seealso [get_key()] will check the system environments for one.
#' @param id the id of what you're looking for. Meaning of the id changes depending on endpoint.
#' @param lang the language you are using and want results returned in.
#'
#' @return a structure with the parsed text response, the raw response, the endpoint path, and the id.
#'
#' @references Note that this function is based on, and repeats much of the code in
#' the R API package best practices,
#' available at <https://httr.r-lib.org/articles/api-packages.html#overall-design-1>.
#'
#' @examples
#' query_api("food")
#' query_api("food", id = 2314)
#' query_api("nutrientgroup", id = 1)
#' query_api("nutrientname", id = 1)
#' query_api("nutrientsource", id = 82)
#' query_api("refuseamount", id = 2314)
#' query_api("servingsize", id = 2314)
#' query_api("yieldamoubt", id = 2314)
#'
#' @export
#'
query_api <- function(path, apiKey = NULL, id = NULL, lang = "en") {
if (is.null(path)){
stop("You need to specify and endpoint.")
}
# Should no key be provided, check to see if one
# is saved as as a system variable.
if (is.null(apiKey)) {
apiKey <- get_key()
}
# Set a user agent.
ua <- user_agent('https://github.com/jufil19/nutrientr')
# Make sure all the necessary components are ready to make a query.
url <- modify_url("https://cnf-hc-sc-apicast-production.api.canada.ca", path = paste('v1/', path, sep = ''))
query <- list(lang = lang, id = id, type = 'json')
header <- add_headers("user-key" = apiKey)
resp <- GET(url, ua, header, query = query)
# Need to verify output was JSON as it should be.
if (http_type(resp) != "application/json") {
# Check status code since the API doesn't return json if there is an error.
if (status_code(resp) != 200) {
stop(
paste("Canadian Nutrient File API request failed:", status_code(resp), rawToChar(resp$content)),
call. = FALSE
)
}
# Otherwise the call was valid but response was not json.
stop("API did not return json", call. = FALSE)
}
# Now parse the text output from the response.
parsed <-  jsonlite::fromJSON(content(resp, "text"), simplifyVector = FALSE)
# Check status code to make sure query was successful and if not provide useful errors.
if (status_code(resp) != 200) {
stop(
paste("Canadian Nutrient File API request failed:", status_code(resp), parsed$Message, parsed$documentation_url),
call. = FALSE
)
}
# Return all of the relevant information in a structure for easy access.
structure(
list(
content = parsed,
path = path,
id = id,
response = resp
),
class = "cn_api"
)
}
library(httr)
library(jsonlite)
api_key <- '664fbadd34e6c2ca75235709f9ede2bd'
url <- 'https://cnf-hc-sc-apicast-production.api.canada.ca/v1/food?type=json&lang=en&id=2314,2315'
header <- add_headers("user-key" = api_key)
res <- GET(url, header, query = list(lang = 'en'))
data = fromJSON(rawToChar(res$content))
path = 'food'
lang = 'en'
id = NULL
apiKey <- api_key
ua <- user_agent('https://github.com/jufil19/nutrientr')
url <- modify_url("https://cnf-hc-sc-apicast-production.api.canada.ca", path = paste('v1/', path, sep = ''))
query <- list(lang = lang, id = id, type = 'json')
header <- add_headers("user-key" = apiKey)
url <- "https://cnf-hc-sc-apicast-production.api.canada.ca/v1/food"
res <- GET(url, ua, header, query = query)
View(ua)
# Helper function that formats the output of the query_api function into a tibble with appropriate column types
# This function will not be visible by users
clean_data <- function(query_api_output) {
df <- as.data.frame(do.call(rbind, query_api_output$content))
# Check if the dataframe is empty
if (nrow(df) == 0) {
stop("The requested query has no result")
}
# Each column is a list, we thus need to unnest every column
# This way, R will be able to attribute the appropriate type to each column
df_unnest <- unnest(df, cols = all_of(colnames(df)))
# output the tibble
df_unnest
}
#' query_api
#' Makes a query to the Canadian Nutrient Files API.
#'
#' @param path the path to the desired endpoint. (Should be one of food, nutrientamount
#' nutrientgroup, nutrientname, nutrientsource, refuseamount, servingsize, or yieldamount.)
#' @param userKey key to access the API. Can be retrieved from <https://hc-sc.api.canada.ca/en/detail?api=cnf#!/Nutrient/get_nutrientamount>.
#' If none is provided, @seealso [get_key()] will check the system environments for one.
#' @param id the id of what you're looking for. Meaning of the id changes depending on endpoint.
#' @param lang the language you are using and want results returned in.
#'
#' @return a structure with the parsed text response, the raw response, the endpoint path, and the id.
#'
#' @references Note that this function is based on, and repeats much of the code in
#' the R API package best practices,
#' available at <https://httr.r-lib.org/articles/api-packages.html#overall-design-1>.
#'
#' @examples
#' query_api("food")
#' query_api("food", id = 2314)
#' query_api("nutrientgroup", id = 1)
#' query_api("nutrientname", id = 1)
#' query_api("nutrientsource", id = 82)
#' query_api("refuseamount", id = 2314)
#' query_api("servingsize", id = 2314)
#' query_api("yieldamoubt", id = 2314)
#'
#' @export
#'
query_api <- function(path, apiKey = NULL, id = NULL, lang = "en") {
if (is.null(path)){
stop("You need to specify and endpoint.")
}
# Should no key be provided, check to see if one
# is saved as as a system variable.
if (is.null(apiKey)) {
apiKey <- get_key()
}
# Set a user agent.
ua <- user_agent('https://github.com/jufil19/nutrientr')
# Make sure all the necessary components are ready to make a query.
url <- modify_url("https://cnf-hc-sc-apicast-production.api.canada.ca", path = paste('v1/', path, sep = ''))
query <- list(lang = lang, id = id, type = 'json')
header <- add_headers("user-key" = apiKey)
resp <- GET(url, ua, header, query = query)
# Need to verify output was JSON as it should be.
if (http_type(resp) != "application/json") {
# Check status code since the API doesn't return json if there is an error.
if (status_code(resp) != 200) {
stop(
paste("Canadian Nutrient File API request failed:", status_code(resp), rawToChar(resp$content)),
call. = FALSE
)
}
# Otherwise the call was valid but response was not json.
stop("API did not return json", call. = FALSE)
}
# Now parse the text output from the response.
parsed <-  jsonlite::fromJSON(content(resp, "text"), simplifyVector = FALSE)
# Check status code to make sure query was successful and if not provide useful errors.
if (status_code(resp) != 200) {
stop(
paste("Canadian Nutrient File API request failed:", status_code(resp), parsed$Message, parsed$documentation_url),
call. = FALSE
)
}
# Return all of the relevant information in a structure for easy access.
structure(
list(
content = parsed,
path = path,
id = id,
response = resp
),
class = "cn_api"
)
}
library(httr)
library(jsonlite)
api_key <- '664fbadd34e6c2ca75235709f9ede2bd'
url <- 'https://cnf-hc-sc-apicast-production.api.canada.ca/v1/food?type=json&lang=en&id=2314,2315'
header <- add_headers("user-key" = api_key)
res <- GET(url, header, query = list(lang = 'en'))
data = fromJSON(rawToChar(res$content))
path = 'food'
lang = 'en'
id = NULL
apiKey <- api_key
ua <- user_agent('https://github.com/jufil19/nutrientr')
url <- modify_url("https://cnf-hc-sc-apicast-production.api.canada.ca", path = paste('v1/', path, sep = ''))
query <- list(lang = lang, id = id, type = 'json')
header <- add_headers("user-key" = apiKey)
url <- "https://cnf-hc-sc-apicast-production.api.canada.ca/v1/food"
res <- GET(url, ua, header, query = query)
#' query_api
#' Makes a query to the Canadian Nutrient Files API.
#'
#' @param path the path to the desired endpoint. (Should be one of food, nutrientamount
#' nutrientgroup, nutrientname, nutrientsource, refuseamount, servingsize, or yieldamount.)
#' @param userKey key to access the API. Can be retrieved from <https://hc-sc.api.canada.ca/en/detail?api=cnf#!/Nutrient/get_nutrientamount>.
#' If none is provided, @seealso [get_key()] will check the system environments for one.
#' @param id the id of what you're looking for. Meaning of the id changes depending on endpoint.
#' @param lang the language you are using and want results returned in.
#'
#' @return a structure with the parsed text response, the raw response, the endpoint path, and the id.
#'
#' @references Note that this function is based on, and repeats much of the code in
#' the R API package best practices,
#' available at <https://httr.r-lib.org/articles/api-packages.html#overall-design-1>.
#'
#' @examples
#' query_api("food")
#' query_api("food", id = 2314)
#' query_api("nutrientgroup", id = 1)
#' query_api("nutrientname", id = 1)
#' query_api("nutrientsource", id = 82)
#' query_api("refuseamount", id = 2314)
#' query_api("servingsize", id = 2314)
#' query_api("yieldamoubt", id = 2314)
#'
#' @export
#'
query_api <- function(path, apiKey = NULL, id = NULL, lang = "en") {
if (is.null(path)){
stop("You need to specify and endpoint.")
}
# Should no key be provided, check to see if one
# is saved as as a system variable.
if (is.null(apiKey)) {
apiKey <- get_key()
}
# Set a user agent.
ua <- user_agent('https://github.com/jufil19/nutrientr')
# Make sure all the necessary components are ready to make a query.
url <- modify_url("https://cnf-hc-sc-apicast-production.api.canada.ca", path = paste('v1/', path, sep = ''))
query <- list(lang = lang, id = id, type = 'json')
header <- add_headers("user-key" = apiKey)
resp <- GET(url, ua, header, query = query)
# Need to verify output was JSON as it should be.
if (http_type(resp) != "application/json") {
# Check status code since the API doesn't return json if there is an error.
if (status_code(resp) != 200) {
stop(
paste("Canadian Nutrient File API request failed:", status_code(resp), rawToChar(resp$content)),
call. = FALSE
)
}
# Otherwise the call was valid but response was not json.
stop("API did not return json", call. = FALSE)
}
# Now parse the text output from the response.
parsed <-  jsonlite::fromJSON(content(resp, "text"), simplifyVector = FALSE)
# Check status code to make sure query was successful and if not provide useful errors.
if (status_code(resp) != 200) {
stop(
paste("Canadian Nutrient File API request failed:", status_code(resp), parsed$Message, parsed$documentation_url),
call. = FALSE
)
}
# Return all of the relevant information in a structure for easy access.
structure(
list(
content = parsed,
path = path,
id = id,
response = resp
),
class = "cn_api"
)
}
# Helper function that formats the output of the query_api function into a tibble with appropriate column types
# This function will not be visible by users
clean_data <- function(query_api_output) {
df <- as.data.frame(do.call(rbind, query_api_output$content))
# Check if the dataframe is empty
if (nrow(df) == 0) {
stop("The requested query has no result")
}
# Each column is a list, we thus need to unnest every column
# This way, R will be able to attribute the appropriate type to each column
df_unnest <- unnest(df, cols = all_of(colnames(df)))
# output the tibble
df_unnest
}
#' Retrieves the API key
#'
#' @description
#' `get_key` stops execution and returns an error message if the environment variable `CN_API` is not set to the user's API key. If the environment
#' variable is not set, the function returns an error message.
#'
#' @return The user's API key, if set as an environment variable. If key is not set, returns an error message indicating that the user can either set
#' the environment variable `CN_API` or pass the API key as an argument to the function.
#' @references Note that this function is based on, and repeats much of the code in
#'   the R API package best practices, available at <https://httr.r-lib.org/articles/api-packages.html#overall-design-1>.
#' @examples
#' get_key()
get_key <- function() {
key <- Sys.getenv("CN_API")
if (key == "") {
stop("An API key is required. Please set environment variable `CN_API` to your API key as so : `Sys.setenv(CN_API = 'your_key')` or pass
an API key as an argument to the function. An API key can be acquired at <https://hc-sc.api.canada.ca/en/detail?api=cnf>", call. = FALSE)
}
key
}
# helper function that skips unit tests if no API key is set
# This function will not be visible by users (inspired by: https://cran.r-project.org/web/packages/httr/vignettes/secrets.html)
skip_if_no_key <- function() {
if (Sys.getenv("CN_API") == "") {
skip("No API key available")
}
}
length(NULL)
api_key <- '664fbadd34e6c2ca75235709f9ede2bd'
url <- 'https://cnf-hc-sc-apicast-production.api.canada.ca/v1/food?type=json&lang=en&id=blorf'
header <- add_headers("user-key" = api_key)
res <- GET(url, header, query = list(lang = 'en'))
styler:::style_selection()
#' get_food
#'
#' Makes a query to the Canadian Nutrient File food endpoint. This endpoint returns
#' data from a list of food codes and corresponding names.
#'
#' @param apiKey Key to access the API. Can be retrieved from
#' <https://hc-sc.api.canada.ca/en/detail?api=cnf#!/Nutrient/get_nutrientamount>.
#' If none is provided, the system environment variables will be checked.
#' @param foodCode The code indicating the food you want to search for. If null,
#' all foods are returned.
#' @param lang The language to return results in, can be either 'en' or 'fr'.
#'
#' @return A tibble containing food names and food ids.
#'
#' @export
#'
#' @examples
#' get_food()
#' get_food(food_code = 2314)
#' get_food(food_code = 2314, lang = "fr")
get_food <- function(apiKey = NULL,
foodCode = NULL,
lang = "en") {
# Query the food endpoint of the api.
output <-
query_api(
path = "food",
apiKey = apiKey,
id = foodCode,
lang = lang
)
# Get a clean tibble from the results and return it.
clean_data(output)
}
#' get_yieldamount
#'
#' Makes a query to the Canadian Nutrient File food endpoint. This endpoint returns
#' data from a list of food codes and corresponding yield amounts (yield from refuse and or
#' cooking losses).
#'
#' @param apiKey Key to access the API. Can be retrieved from
#' <https://hc-sc.api.canada.ca/en/detail?api=cnf#!/Nutrient/get_nutrientamount>.
#' If none is provided, the system environment variables will be checked.
#' @param foodCode The code indicating the food you want to search for. If null,
#' all foods and their corresponding yields are returned.
#' @param lang The language to return results in, can be either 'en' or 'fr'.
#'
#' @return A tibble containing food names and food codes, yield amounts, and yield names.
#'
#' @export
#'
#' @examples
#' get_yieldamount()
#' get_yieldamount(food_code = 2314)
#' get_yieldamount(food_code = 2314, lang = "fr")
get_yieldamount <- function(apiKey = NULL,
foodCode = NULL,
lang = "en") {
# Query the food endpoint of the api.
output <-
query_api(
path = "yieldamount",
apiKey = apiKey,
id = foodCode,
lang = lang
)
# Get a clean tibble from the results and return it.
clean_data(output)
}
get_food(foodCode = 2314)
get_food(api_key, foodCode = 2314)
library(tidyverse)
get_food(api_key, foodCode = 2314)
get_food(api_key, foodCode = 2315)
get_yieldamount(api_key, foodCode = 2315)
get_yieldamount(api_key, foodCode = 2314)
get_yieldamount(api_key, foodCode = 2316)
get_food(api_key, foodCode = 23)
get_food(api_key, foodCode = 26)
get_yieldamount(api_key, foodCode = 26)
get_food(api_key, foodCode = 235)
get_food(api_key, foodCode = 47)
get_food(api_key, foodCode = 1000)
get_yieldamount(api_key, foodCode = 1000)
get_yieldamount(api_key, foodCode = "kaka")
get_yieldamount(api_key, foodCode = 32)
get_yieldamount(api_key, foodCode = 800)
get_yieldamount(api_key, foodCode = 1002)
