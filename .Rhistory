}
# Should no key be provided, check to see if one
# is saved as as a system variable.
if (is.null(apiKey)) {
get_key()
}
# Set a user agent.
ua <- user_agent('https://github.com/jufil19/nutrientr')
# Make sure all the necessary components are ready to make a query.
url <- modify_url("https://cnf-hc-sc-apicast-production.api.canada.ca", path = paste('v1/', path, sep = ''))
query <- list(lang = lang, id = id, type = 'json')
header <- add_headers("user-key" = apiKey)
resp <- GET(url, ua, header, query = query)
# Need to verify output was JSON as it should be.
if (http_type(resp) != "application/json") {
stop("API did not return json", call. = FALSE)
}
# Now parse the text output from the response.
parsed <- jsonlite::fromJSON(content(resp, "text"), simplifyVector = FALSE)
# Check status code to make sure query was successful and if not provide useful errors.
if (status_code(resp) != 200) {
stop(
paste("Canadian Nutrient File API request failed:", status_code(resp), parsed$Message, parsed$documentation_url),
call. = FALSE
)
}
# Return all of the relevant information in a structure for easy access.
structure(
list(
content = parsed,
path = path,
id = id,
response = resp
),
class = "cn_api"
)
}
cn_api <- function(path, apiKey = NULL, id = NULL, lang = "en") {
if (is.null(path)){
stop("You need to specify and endpoint.")
}
# Should no key be provided, check to see if one
# is saved as as a system variable.
if (is.null(apiKey)) {
apiKey <- get_key()
}
# Set a user agent.
ua <- user_agent('https://github.com/jufil19/nutrientr')
# Make sure all the necessary components are ready to make a query.
url <- modify_url("https://cnf-hc-sc-apicast-production.api.canada.ca", path = paste('v1/', path, sep = ''))
query <- list(lang = lang, id = id, type = 'json')
header <- add_headers("user-key" = apiKey)
resp <- GET(url, ua, header, query = query)
# Need to verify output was JSON as it should be.
if (http_type(resp) != "application/json") {
stop("API did not return json", call. = FALSE)
}
# Now parse the text output from the response.
parsed <- jsonlite::fromJSON(content(resp, "text"), simplifyVector = FALSE)
# Check status code to make sure query was successful and if not provide useful errors.
if (status_code(resp) != 200) {
stop(
paste("Canadian Nutrient File API request failed:", status_code(resp), parsed$Message, parsed$documentation_url),
call. = FALSE
)
}
# Return all of the relevant information in a structure for easy access.
structure(
list(
content = parsed,
path = path,
id = id,
response = resp
),
class = "cn_api"
)
}
cn_api(path = 'food')
Sys.getenv('CN_API')
Sys.setenv(CN_API = 'c2eedfce1c1e820292a7d356bb8c0975')
Sys.getenv('CN_API')
cn_api <- function(path, apiKey = NULL, id = NULL, lang = "en") {
if (is.null(path)){
stop("You need to specify and endpoint.")
}
# Should no key be provided, check to see if one
# is saved as as a system variable.
if (is.null(apiKey)) {
apiKey <- get_key()
}
# Set a user agent.
ua <- user_agent('https://github.com/jufil19/nutrientr')
# Make sure all the necessary components are ready to make a query.
url <- modify_url("https://cnf-hc-sc-apicast-production.api.canada.ca", path = paste('v1/', path, sep = ''))
query <- list(lang = lang, id = id, type = 'json')
header <- add_headers("user-key" = apiKey)
resp <- GET(url, ua, header, query = query)
# Need to verify output was JSON as it should be.
if (http_type(resp) != "application/json") {
stop("API did not return json", call. = FALSE)
}
# Now parse the text output from the response.
parsed <- jsonlite::fromJSON(content(resp, "text"), simplifyVector = FALSE)
# Check status code to make sure query was successful and if not provide useful errors.
if (status_code(resp) != 200) {
stop(
paste("Canadian Nutrient File API request failed:", status_code(resp), parsed$Message, parsed$documentation_url),
call. = FALSE
)
}
# Return all of the relevant information in a structure for easy access.
structure(
list(
content = parsed,
path = path,
id = id,
response = resp
),
class = "cn_api"
)
}
cn_api(path = 'food')
library(httr)
cn_api <- function(path, apiKey = NULL, id = NULL, lang = "en") {
if (is.null(path)){
stop("You need to specify and endpoint.")
}
# Should no key be provided, check to see if one
# is saved as as a system variable.
if (is.null(apiKey)) {
apiKey <- get_key()
}
# Set a user agent.
ua <- user_agent('https://github.com/jufil19/nutrientr')
# Make sure all the necessary components are ready to make a query.
url <- modify_url("https://cnf-hc-sc-apicast-production.api.canada.ca", path = paste('v1/', path, sep = ''))
query <- list(lang = lang, id = id, type = 'json')
header <- add_headers("user-key" = apiKey)
resp <- GET(url, ua, header, query = query)
# Need to verify output was JSON as it should be.
if (http_type(resp) != "application/json") {
stop("API did not return json", call. = FALSE)
}
# Now parse the text output from the response.
parsed <- jsonlite::fromJSON(content(resp, "text"), simplifyVector = FALSE)
# Check status code to make sure query was successful and if not provide useful errors.
if (status_code(resp) != 200) {
stop(
paste("Canadian Nutrient File API request failed:", status_code(resp), parsed$Message, parsed$documentation_url),
call. = FALSE
)
}
# Return all of the relevant information in a structure for easy access.
structure(
list(
content = parsed,
path = path,
id = id,
response = resp
),
class = "cn_api"
)
}
cn_api(path = 'food')
cn_api(path = 'food')[1:10]
test <- cn_api(path = 'food')
View(test)
test <- as.data.frame(test)
test <- cn_api(path = 'food')
t <- as.data.frame(test)
t <- as.data.frame(test$content)
View(t)
View(test)
unlist(test$content)
t <- as.data.frame(unlist(test$content))
View(t)
t <- as.data.frame(unlist(test$content$ResultSet))
View(t)
unlist(test$content)
unlist(test$content)[,1]
test$content
cn_api <- function(path, apiKey = NULL, id = NULL, lang = "en") {
if (is.null(path)){
stop("You need to specify and endpoint.")
}
# Should no key be provided, check to see if one
# is saved as as a system variable.
if (is.null(apiKey)) {
apiKey <- get_key()
}
# Set a user agent.
ua <- user_agent('https://github.com/jufil19/nutrientr')
# Make sure all the necessary components are ready to make a query.
url <- modify_url("https://cnf-hc-sc-apicast-production.api.canada.ca", path = paste('v1/', path, sep = ''))
query <- list(lang = lang, id = id, type = 'json')
header <- add_headers("user-key" = apiKey)
resp <- GET(url, ua, header, query = query)
# Need to verify output was JSON as it should be.
if (http_type(resp) != "application/json") {
stop("API did not return json", call. = FALSE)
}
# Now parse the text output from the response.
parsed <- jsonlite::fromJSON(rawToChar(res$content))
# Check status code to make sure query was successful and if not provide useful errors.
if (status_code(resp) != 200) {
stop(
paste("Canadian Nutrient File API request failed:", status_code(resp), parsed$Message, parsed$documentation_url),
call. = FALSE
)
}
# Return all of the relevant information in a structure for easy access.
structure(
list(
content = parsed,
path = path,
id = id,
response = resp
),
class = "cn_api"
)
}
test <- cn_api(path = 'food')
cn_api <- function(path, apiKey = NULL, id = NULL, lang = "en") {
if (is.null(path)){
stop("You need to specify and endpoint.")
}
# Should no key be provided, check to see if one
# is saved as as a system variable.
if (is.null(apiKey)) {
apiKey <- get_key()
}
# Set a user agent.
ua <- user_agent('https://github.com/jufil19/nutrientr')
# Make sure all the necessary components are ready to make a query.
url <- modify_url("https://cnf-hc-sc-apicast-production.api.canada.ca", path = paste('v1/', path, sep = ''))
query <- list(lang = lang, id = id, type = 'json')
header <- add_headers("user-key" = apiKey)
resp <- GET(url, ua, header, query = query)
# Need to verify output was JSON as it should be.
if (http_type(resp) != "application/json") {
stop("API did not return json", call. = FALSE)
}
# Now parse the text output from the response.
parsed <- jsonlite::fromJSON(rawToChar(resp$content))
# Check status code to make sure query was successful and if not provide useful errors.
if (status_code(resp) != 200) {
stop(
paste("Canadian Nutrient File API request failed:", status_code(resp), parsed$Message, parsed$documentation_url),
call. = FALSE
)
}
# Return all of the relevant information in a structure for easy access.
structure(
list(
content = parsed,
path = path,
id = id,
response = resp
),
class = "cn_api"
)
}
test <- cn_api(path = 'food')
View(test)
t <- test$content
View(t)
cn_api <- function(path, apiKey = NULL, id = NULL, lang = "en") {
if (is.null(path)){
stop("You need to specify and endpoint.")
}
# Should no key be provided, check to see if one
# is saved as as a system variable.
if (is.null(apiKey)) {
apiKey <- get_key()
}
# Set a user agent.
ua <- user_agent('https://github.com/jufil19/nutrientr')
# Make sure all the necessary components are ready to make a query.
url <- modify_url("https://cnf-hc-sc-apicast-production.api.canada.ca", path = paste('v1/', path, sep = ''))
query <- list(lang = lang, id = id, type = 'json')
header <- add_headers("user-key" = apiKey)
resp <- GET(url, ua, header, query = query)
# Need to verify output was JSON as it should be.
if (http_type(resp) != "application/json") {
stop("API did not return json", call. = FALSE)
}
# Now parse the text output from the response.
parsed <- jsonlite::fromJSON(rawToChar(resp$content))
# Check status code to make sure query was successful and if not provide useful errors.
if (status_code(resp) != 200) {
stop(
paste("Canadian Nutrient File API request failed:", status_code(resp), parsed$Message, parsed$documentation_url),
call. = FALSE
)
}
# Return all of the relevant information in a structure for easy access.
structure(
list(
content = parsed,
path = path,
id = id,
response = resp
),
class = "cn_api"
)
}
test <- cn_api(path = 'food')
t <- test$content
View(t)
test <- cn_api(path = 'food', lang = 'fr')
t <- test$content
View(t)
Encoding(test$content) <- "UTF-8"
Encoding(test$content$food_description) <- "UTF-8"
View(t)
for (col in colnames(test$content)){
Encoding(test$content[[col]]) <- "UTF-8"}
for (col in colnames(test$content)){
Encoding(test$content[[col]]) <- "UTF-8"}
for (col in colnames(test$content)){
print(col)
Encoding(test$content[[col]]) <- "UTF-8"}
for (col in colnames(test$content)){
print(col)
Encoding(test$content$col) <- "UTF-8"}
Encoding(test$content$food_description) <- "UTF-8"
View(test)
Encoding(t$food_description) <- "UTF-8"
View(t)
?do.call
cn_api <- function(path, apiKey = NULL, id = NULL, lang = "en") {
if (is.null(path)){
stop("You need to specify and endpoint.")
}
# Should no key be provided, check to see if one
# is saved as as a system variable.
if (is.null(apiKey)) {
apiKey <- get_key()
}
# Set a user agent.
ua <- user_agent('https://github.com/jufil19/nutrientr')
# Make sure all the necessary components are ready to make a query.
url <- modify_url("https://cnf-hc-sc-apicast-production.api.canada.ca", path = paste('v1/', path, sep = ''))
query <- list(lang = lang, id = id, type = 'json')
header <- add_headers("user-key" = apiKey)
resp <- GET(url, ua, header, query = query)
# Need to verify output was JSON as it should be.
if (http_type(resp) != "application/json") {
stop("API did not return json", call. = FALSE)
}
# Now parse the text output from the response.
parsed <- jsonlite::fromJSON(content(resp, "text"), simplifyVector = FALSE)
# Check status code to make sure query was successful and if not provide useful errors.
if (status_code(resp) != 200) {
stop(
paste("Canadian Nutrient File API request failed:", status_code(resp), parsed$Message, parsed$documentation_url),
call. = FALSE
)
}
# Return all of the relevant information in a structure for easy access.
structure(
list(
content = parsed,
path = path,
id = id,
response = resp
),
class = "cn_api"
)
}
test <- cn_api(path = 'food', lang = 'fr')
test <- as.data.frame(do.call(rbind, cn_api(path = 'food', lang = 'fr')$content))
View(test)
test <- as.data.frame(do.call(rbind, cn_api(path = 'nutrient amount', lang = 'fr')$content))
test <- as.data.frame(do.call(rbind, cn_api(path = 'nutrientamount', lang = 'fr')$content))
View(test)
test <- as.data.frame(do.call(rbind, cn_api(path = 'nutrientamount', lang = 'en')$content))
View(test)
test <- as.data.frame(do.call(rbind, cn_api(path = 'nutrientamount', lang = 'en')$content))
test[, grep("Type", colnames(test))]
View(test)
colnames(test)
typeof(test)
View(test)
typeof(test$food_code)
head(test)
head(test$food_code)
test <- as.data.frame(unlist(do.call(rbind, cn_api(path = 'nutrientamount', lang = 'en')$content)))
View(test)
do.call(rbind, cn_api(path = 'food', lang = 'en')$content)
as.data.frame(do.call(rbind, resp$content))
as.data.frame(do.call(rbind, cn_api(path = 'food', lang = 'en')$content))
test <- as.data.frame(do.call(rbind, resp$content), row.names = NULL)
as.data.frame(do.call(rbind, cn_api(path = 'food', lang = 'en')$content), row.names = NULL)
test2 <- as.data.frame(do.call(rbind, cn_api(path = 'food', lang = 'en')$content))
is.data.frame(test2)
head(test2)
head(test2)$food_code
typeof(test2$food_code)
unnest(test2)
library(stringr)
library(tidyr)
library(tidyverse)
unnest(test2)
View(test2)
test3 <- unnest(test2, cols = c(food_code, food_description))
View(test3)
test <- as.data.frame(do.call(rbind, cn_api(path = 'nutrientamount', lang = 'en')$content))
View(test)
colnames(test)
col_names <- colnames(test)
typeof(col_names)
col_names2 <- colnames(test2)
?unnest
col_names
test_unnest <- unnest(test, cols = c(food_code, nutrient_value, standard_error, number_observation, nutrient_name_id, nutrient_web_name, nutrient_source_id))
View(test_unnest)
col_names <- colnames(test)
colnames(test)
c(col_names) <- colnames(test)
col_names <- c(colnames(test))
col_names
typeof(col_names)
h <- c("a", "b")
typeof(h)
test2 <- as.data.frame(do.call(rbind, cn_api(path = 'food', lang = 'en')$content))
cn_api <- function(path, apiKey = NULL, id = NULL, lang = "en") {
if (is.null(path)){
stop("You need to specify and endpoint.")
}
# Should no key be provided, check to see if one
# is saved as as a system variable.
if (is.null(apiKey)) {
apiKey <- get_key()
}
# Set a user agent.
ua <- user_agent('https://github.com/jufil19/nutrientr')
# Make sure all the necessary components are ready to make a query.
url <- modify_url("https://cnf-hc-sc-apicast-production.api.canada.ca", path = paste('v1/', path, sep = ''))
query <- list(lang = lang, id = id, type = 'json')
header <- add_headers("user-key" = apiKey)
resp <- GET(url, ua, header, query = query)
# Need to verify output was JSON as it should be.
if (http_type(resp) != "application/json") {
stop("API did not return json", call. = FALSE)
}
# Now parse the text output from the response.
parsed <- jsonlite::fromJSON(content(resp, "text"), simplifyVector = FALSE)
# Check status code to make sure query was successful and if not provide useful errors.
if (status_code(resp) != 200) {
stop(
paste("Canadian Nutrient File API request failed:", status_code(resp), parsed$Message, parsed$documentation_url),
call. = FALSE
)
}
# Return all of the relevant information in a structure for easy access.
structure(
list(
content = parsed,
path = path,
id = id,
response = resp
),
class = "cn_api"
)
}
get_key <- function() {
key <- Sys.getenv("CN_API")
if (key == "") {
stop("An API key is required. Please set environment variable `CN_API` to your API key as so : `Sys.setenv(CN_API = 'your_key')` or pass
an API key as an argument to the function. An API key can be acquired at <https://hc-sc.api.canada.ca/en/detail?api=cnf>", call. = FALSE)
}
key
}
skip_if_no_key <- function() {
if (Sys.getenv("CN_API") == "") {
skip("No API key available")
}
}
nutrient <- as.data.frame(do.call(rbind, cn_api(path = 'nutrientamount', lang = 'en')$content))
col_names_nutrient <- c(colnames(nutrient))
food <- as.data.frame(do.call(rbind, cn_api(path = 'food', lang = 'en')$content))
col_names_food <- colnames(food)
col_names_food <- c(colnames(food))
test3 <- unnest(test2, cols = col_names_food)
food_unnest <- unnest(food, cols = col_names_food)
col_names_food <- colnames(food)
food_unnest <- unnest(food, cols = all_of(col_names_food))
View(food_unnest)
?stop
styler:::style_selection()
cn_cleandata <- function(cn_api_output) {
df <- as.data.frame(do.call(rbind, cn_api_output$content))
# Check if the dataframe is empty
if (nrow(df) == 0) {
stop("The requested query has no result")
}
# Each column is a list, we thus need to unnest every column
# This way, R will be able to attribute the appropriate type to each column
df_unnest <- unnest(df, cols = all_of(colnames(df)))
# output the dataframe
df_unnest
}
cn_cleandata(cn_api(path = 'food', lang = 'en'))
cn_api(path = 'food', lang = 'en')
cn_api(path = 'nutrientamount', lang = 'en')
cn_api(path = 'food', lang = 'en')
cn_api(path = 'food', lang = 'en')
cn_cleandata(cn_api(path = 'food', lang = 'en'))
yessir <- cn_cleandata(cn_api(path = 'food', lang = 'en'))
View(yessir)
usethis::use_package('tidyr')
